#!@GUILE@ \
-e main
!#

;;; dsv.in -- Get various information from DSV files.

;; Copyright (C) 2015, 2016, 2017, 2020, 2021 Artyom V. Poptsov <poptsov.artyom@gmail.com>
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; The program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with the program.  If not, see <http://www.gnu.org/licenses/>.


;;; Commentary:

;; A handy tool to get various information from DSV files.
;;
;; Configurable table elements:
;;   - top (t)
;;   - top-left (tl)
;;   - top-right (tr)
;;   - top-joint (tj)
;;   - horizontal (h)
;;   - horizontal-left (hl)
;;   - horizontal-right (hr)
;;   - horizontal-joint (hj)
;;   - vertical (v)
;;   - bottom (b)
;;   - bottom-left (bl)
;;   - bottom-right (br)
;;   - bottom-joint (bj)


;;; Code:

(use-modules (ice-9 getopt-long)
             (ice-9 rdelim)
             (ice-9 format)
             (ice-9 textual-ports)
             (ice-9 regex)
             (ice-9 ftw)
             (scheme documentation)
             (srfi  srfi-1)
             (srfi  srfi-26)
             (dsv)
             (dsv common))



(define %table-presets-path
  "@DATA_DIR@/presets/")

(define-with-docs %table-parameters
  "Associative list of all known table parameters."
  '((bt  . border-top)
    (btl . border-top-left)
    (btr . border-top-right)
    (btj . border-top-joint)
    (bl  . border-left)
    (blj . border-left-joint)
    (br  . border-right)
    (brj . border-right-joint)
    (bb  . border-bottom)
    (bbl . border-bottom-left)
    (bbr . border-bottom-right)
    (bbj . border-bottom-joint)
    ;; Inner table lines.
    (rs  . row-separator)
    (rj  . row-joint)
    (cs  . column-separator)
    ;; Headers.
    (ht  . header-top)
    (htl . header-top-left)
    (htr . header-top-right)
    (htj . header-top-joint)
    (hl  . header-left)
    (hr  . header-right)
    (hcs . header-column-separator)
    (hb  . header-bottom)
    (hbl . header-bottom-left)
    (hbr . header-bottom-right)
    (hbj . header-bottom-joint)))

(define (print-table-parameters port)
  "Print all known table parameters to a PORT."
  (for-each (lambda (param)
              (format port
                      "  ~4a ~a~%"
                      (car param)
                      (cdr param)))
            %table-parameters))

(define (print-table-presets port)
  "Print all known table presets to a PORT."
  (let ((dir (scandir %table-presets-path
                      (lambda (name)
                        (not (string-prefix? "." name))))))
    (for-each (lambda (d)
                (format port
                        "  ~a~%"
                        (car (string-split d #\.))))
              dir)))



(define (string->dsv-format str)
  "Convert a string STR to a DSV format type."
  (let ((fmt (string->symbol str)))
    (case fmt
      ((unix rfc4180)
       fmt)
      (else
       (error "Wrong format" str)))))

(define (remove-empty-rows table)
  (remove (lambda (f)
            (and (= (length f) 1)
                 (string-null? (car f))))
          table))

(define (rc file delim fmt)
  "Get number of records in a FILE."
  (let ((p (open-input-file file)))
    (length (dsv->scm p delim #:format fmt))))


(define (guess-file-delimiter input-port fmt)
  "Guess delimiter for a file."
  (let guess ((line (read-line input-port 'concat))
              (buf  '()))
    (and (not (eof-object? line))
         (let ((guessed-delim (guess-delimiter line #:format fmt)))
           (if guessed-delim
               (begin
                 (for-each (lambda (str)
                             (unget-string input-port str))
                           (cons line buf))
                 guessed-delim)
               (guess (read-line input-port)
                      (cons line buf)))))))


(define (get-width table)
  "Get maximum field width for each row of TABLE."
  (let loop ((rows table)
             (res  '()))
    (if (not (null? rows))
        (let ((w (map string-length (car rows))))
          (cond
           ((null? res)
            (loop (cdr rows) w))
           (else
            (loop (cdr rows)
                  (map max res w)))))
        res)))

(define* (format-table table borders #:key (with-header? #f))
  "Format file and print it."
  (let* ((padding 5)
         (column-separator    (or (assoc-ref borders 'column-separator) ""))
         (row-separator       (assoc-ref borders 'row-separator))
         (row-joint           (assoc-ref borders 'row-joint))
         (border-top          (assoc-ref borders 'border-top))
         (border-top-left     (assoc-ref borders 'border-top-left))
         (border-top-right    (assoc-ref borders 'border-top-right))
         (border-top-joint    (assoc-ref borders 'border-top-joint))
         (border-left         (assoc-ref borders 'border-left))
         (border-left-joint   (assoc-ref borders 'border-left-joint))
         (border-right        (assoc-ref borders 'border-right))
         (border-right-joint  (assoc-ref borders 'border-right-joint))
         (border-bottom       (assoc-ref borders 'border-bottom))
         (border-bottom-left  (assoc-ref borders 'border-bottom-left))
         (border-bottom-right (assoc-ref borders 'border-bottom-right))
         (border-bottom-joint (assoc-ref borders 'border-bottom-joint))
         (header-top          (assoc-ref borders 'header-top))
         (header-top-left     (assoc-ref borders 'header-top-left))
         (header-top-right    (assoc-ref borders 'header-top-right))
         (header-top-joint    (assoc-ref borders 'header-top-joint))
         (header-left         (assoc-ref borders 'header-left))
         (header-right        (assoc-ref borders 'header-right))
         (header-column-separator (assoc-ref borders
                                             'header-column-separator))
         (header-bottom       (assoc-ref borders 'header-bottom))
         (header-bottom-left  (assoc-ref borders 'header-bottom-left))
         (header-bottom-right (assoc-ref borders 'header-bottom-right))
         (header-bottom-joint (assoc-ref borders 'header-bottom-joint))
         (width        (get-width table))
         (format-field (lambda (field width)
                         "Print a FIELD in a column with given WIDTH."
                         (format #t (format #f " ~~~da " (+ width padding))
                                 field)))
         (format-row   (lambda (row width border-left border-right separator)
                         (if border-left
                             (display border-left)
                             (display " "))
                         (let field-loop ((fields       row)
                                          (field-widths width))
                           (unless (null? fields)
                             (let ((f (car fields))
                                   (w (car field-widths)))
                               (format-field f w)
                               (if (null? (cdr fields))
                                   (if border-right
                                       (display border-right)
                                       (display " "))
                                   (if separator
                                       (display separator)
                                       (display " ")))
                               (field-loop (cdr fields) (cdr field-widths)))))
                         (newline)))
         (display-line (lambda (widths middle left right joint)
                         (if left
                             (display left)
                             (display " "))
                         (let loop ((w widths))
                           (unless (null? w)
                             (let ((row-width (+ (car w) padding 2)))
                               (display (string-join (make-list row-width
                                                                middle)
                                                     ""))
                               (unless (null? (cdr w))
                                 (if joint
                                     (display joint)
                                     (display " "))))
                             (loop (cdr w))))
                         (if right
                             (display right)
                             (display " "))
                         (newline)))
         (display-header-border-top
          (lambda (widths)
            (display-line widths
                          header-top
                          header-top-left
                          header-top-right
                          header-top-joint)))
         (display-header-border-bottom
          (lambda (widths)
            (display-line widths
                          header-bottom
                          header-bottom-left
                          header-bottom-right
                          header-bottom-joint)))
         (display-top-border (lambda (widths)
                               "Display a top horisontal table border."
                               (display-line widths
                                             border-top
                                             border-top-left
                                             border-top-right
                                             border-top-joint)))
         (display-bottom-border (lambda (widths)
                                  "Display a top horisontal table border."
                                  (display-line widths
                                                border-bottom
                                                border-bottom-left
                                                border-bottom-right
                                                border-bottom-joint)))
         (display-row-separator (lambda (widths)
                                  "Display a top horisontal table border."
                                  (display-line widths
                                                row-separator
                                                border-left-joint
                                                border-right-joint
                                                row-joint)))
         (display-table (lambda (table)
                          (unless with-header?
                            (when border-top
                              (display-top-border width)))
                          (let loop ((t table))
                            (unless (null? t)
                              (format-row (car t)
                                          width
                                          border-left
                                          border-right
                                          column-separator)
                              (when row-separator
                                (if (null? (cdr t))
                                    (when border-bottom
                                      (display-bottom-border width))
                                    (display-row-separator width)))
                              (loop (cdr t)))))))
    (if with-header?
        (begin
          (when header-top
            (display-header-border-top width))
          (format-row (car table)
                      width
                      header-left
                      header-right
                      header-column-separator)
          (when header-bottom
            (display-header-border-bottom width))
          (display-table (cdr table)))
        (display-table table))))

(define (shorthand->table-parameter sh)
  "Convert a shorthand SH to a table parameter."
  (let ((param (assoc-ref %table-parameters sh)))
    (unless param
      (format (current-error-port)
              "ERROR: Unknown table parameter: ~a~%" sh)
      (format (current-error-port)
              "Known table parameters are:~%")
      (print-table-parameters (current-error-port))
      (exit 1))
    param))

(define (borders->alist borders)
  "Convert BORDERS spec to an alist."
  (if (not (string-null? borders))
      (map (lambda (s)
             (let ((lst (string-split s #\=)))
               (cons (shorthand->table-parameter (string->symbol (car lst)))
                     (cadr lst))))
           (car (dsv-string->scm borders #\,)))
      '()))

(define (load-table-borders file)
  "Read table borders specification form a FILE.  Return the specification as a
+list."
  (let ((file-path (string-append %table-presets-path
                                   file
                                   ".scm")))
    (unless (file-exists? file-path)
      (format (current-error-port)
              "Could not find a preset \"~a\" (no such file: \"~a\")~%" file file-path)
      (format (current-error-port)
              "Known presets are:~%")
      (print-table-presets (current-error-port))
      (exit 1))
    (let ((p (open-input-file file-path)))
      (let ((result (read p)))
        (close p)
        result))))

(define (preset-name? spec)
  "Check if a SPEC is a table preset name."
  (string-match "^[a-zA-Z\\-]+$" spec))

(define* (print-file input-port fmt borders delim #:key (with-header? #f))
  "Pretty-print a FILE."
  (let ((delim (or delim (guess-file-delimiter input-port fmt))))

    (unless delim
      (error "Could not determine a file delimiter" input-port))

    (let ((table (remove-empty-rows (dsv->scm input-port delim #:format fmt)))
          (bspec (if (preset-name? borders)
                     (load-table-borders borders)
                     (borders->alist borders))))
      (format-table table bspec #:with-header? with-header?))))


(define (print-summary input-port fmt delim)
  "Print summary information for an INPUT-PORT of format FMT."
  (let ((guessed-delim (or delim (guess-file-delimiter input-port fmt)))
        (f             (cut format #t <...>)))

    (f "File:      ~a~%" (or (port-filename input-port)
                             ""))
    (f "Format:    ~a~%" fmt)
    (f "Delimiter: '~a'~a~%"
       (or guessed-delim "")
       (if guessed-delim
           (format #f " (0x~x)" (char->integer guessed-delim))
           ""))

    (when guessed-delim
      (let* ((table  (remove-empty-rows
                      (dsv->scm input-port guessed-delim
                                #:format fmt)))
             (wtable (let loop ((w   (get-width table))
                                (col 1)
                                (res '()))
                       (if (not (null? w))
                           (loop (cdr w)
                                 (1+ col)
                                 (cons (list (number->string col)
                                             (number->string (car w)))
                                       res))
                           (reverse res)))))
        (f "Records:   ~a~%" (length table))
        (newline)
        (format-table (cons '("column" "width") wtable) '())))))

(define (convert input-port source-delim target-delim source-format target-format)
  "Convert a data from an INPUT-PORT from a SOURCE-FORMAT to a TARGET-FORMAT."
  (case target-format
    ((unix rfc4180)
     (let ((source-delim (or source-delim
                             (guess-file-delimiter input-port source-format)))
           (target-delim (or target-delim 'default)))
       (unless source-delim
         (error "Could not determine a file delimiter" input-port))
       (let ((table (remove-empty-rows (dsv->scm input-port source-delim
                                                 #:format source-format))))
         (scm->dsv table (current-output-port) target-delim
                   #:format target-format))))
    (else
     (error "Unsupported target format" target-format))))

(define (print-delimiter input-port fmt)
  "Guess and print FILE delimiter."
  (let ((guessed-delim (guess-file-delimiter input-port fmt)))
    (format #t "~a~%" (or guessed-delim ""))))

(define (print-help-and-exit)
    (display "\
Usage: dsv [options] <file>

The default behavior of the program is to print a formatted table from a
<file> to stdout.  The options listed below can be used to change or modify
this behavior.

Options:
  --help, -h                 Print this message and exit.
  --summary, -s              Print summary information for a file.
  --delimiter, -D <delim>    Set a delimiter.
  --guess-delimiter, -d      Guess a file delimiter and print the result.
  --file-format, -F <fmt>    Set a file format.  Possible formats are:
                             \"unix\" (default), \"rfc4180\"
  --table-borders, -b <spec> Set table borders for printing.  The value can be
                             either a borders specification or a preset name.

                             Spec is expected to be a comma-separated list of
                             key=value pairs.  The list of possible keys can be
                             found below (see \"Table parameters\".)

                             Example values:
                               - \"v=|,h=-,j=+\"

  --to, -t <fmt>             Convert a file to a specified format, write
                             the result to stdout.
  --to-delimiter, -T <delim> Convert delimiters to the specified variant.
                             When this option is not used, default delimiters
                             for the chosen output format will be used.
  --debug                    Enable state machine debugging.

Table parameters:
")
    (print-table-parameters (current-output-port))
    (display "\nTable presets:\n")
    (print-table-presets (current-output-port))
  (exit))

(define (main args)
  (let* ((option-spec '((help            (single-char #\h) (value #f))
                        (summary         (single-char #\s) (value #f))
                        (delimiter       (single-char #\D) (value #t))
                        (to-delimiter    (single-char #\T) (value #t))
                        (file-format     (single-char #\F) (value #t))
                        (with-header     (single-char #\H) (value #f))
                        (table-borders   (single-char #\b) (value #t))
                        (guess-delimiter (single-char #\d) (value #f))
                        (to              (single-char #\t) (value #t))
                        (debug                             (value #f))))
         (options (getopt-long args option-spec))
         ;; Options
         (help-needed?      (option-ref options 'help            #f))
         (summary-needed?   (option-ref options 'summary         #f))
         (guess-delimiter?  (option-ref options 'guess-delimiter #f))
         (file-format       (option-ref options 'file-format     "unix"))
         (delimiter         (and=> (option-ref options 'delimiter #f)
                                   (cut string-ref <> 0)))
         (to-delimiter      (and=> (option-ref options 'to-delimiter #f)
                                   (cut string-ref <> 0)))
         (with-header?      (option-ref options 'with-header     #f))
         (table-borders     (option-ref options 'table-borders   ""))
         (to                (option-ref options 'to              #f))
         (debug?            (option-ref options 'debug           #f))
         (args              (option-ref options '()              #f)))

    (set-debug! debug?)

    (when help-needed?
      (print-help-and-exit))

    (let ((input-port (if (null? args)
                          (current-input-port)
                          (open-input-file (car args)))))
      (cond
       (summary-needed?
        (print-summary input-port (string->dsv-format file-format) delimiter))
       (guess-delimiter?
        (print-delimiter input-port (string->dsv-format file-format)))
       (to
        (convert input-port
                 delimiter
                 to-delimiter
                 (string->dsv-format file-format)
                 (string->symbol to)))
       (else
        (print-file input-port
                    (string->dsv-format file-format) table-borders
                    delimiter
                    #:with-header? with-header?)))

      (close input-port))
    (exit)))


;;;

;; Local Variables:
;; mode: Scheme
;; End:

;;; dsv.in ends here
